# ğŸ§ª Lab 1 â€“ Web Application Vulnerabilities and Remediation Techniques

## ğŸ“ Overview

In this lab, I worked as a **Security Analyst** to find and fix a **Cross-Site Scripting (XSS)** vulnerability in a web application. I deployed a vulnerable Python Flask app on a Google Cloud VM, tested it with an injection, scanned it using **Web Security Scanner (WSS)**, fixed the vulnerability in the code, and re-scanned to confirm the remediation.

---

## ğŸ¯ Objectives

- Deploy a vulnerable Flask web app on Google Cloud.
- Simulate a Cross-Site Scripting (XSS) attack to confirm the vulnerability.
- Use **Web Security Scanner** to scan the application.
- Remediate the vulnerability with proper input sanitization.
- Re-run the scan to validate the fix.

---

## ğŸ§° Tools & Services Used

- **Google Cloud Platform (GCP)**
- **Compute Engine** (Virtual Machines)
- **Cloud Shell & SSH-in-browser**
- **Web Security Scanner (WSS)**
- **Python Flask Framework**

---

## ğŸ” Task Breakdown

---

### ğŸ§© Task 1 â€“ Launch a Virtual Machine

I created a VM on Google Cloud with no service account or additional scopes, then reserved a **static IP**. I also installed `python3-flask` using a startup script.

ğŸ“¸ **Evidence:**  

VM successfully created:  
![VM Created](./Screenshots_Lab1/01_VM_Created.png)

Static IP generated for external access:  
![Static IP Generated](./Screenshots_Lab1/02_Static_IP_Generated.png)

VM instance confirmation from Compute Engine:  
![VM Instance Confirmation](./Screenshots_Lab1/03_VM_Instance_Confirmation.png)

---

### ğŸ” Task 2 â€“ Set Up and Run the Vulnerable Application

I created a **firewall rule** to allow traffic on port `8080`, connected to the VM via SSH, downloaded the vulnerable Flask app, and started the server.

ğŸ“¸ **Evidence:**  

Firewall rule created to allow HTTP traffic:  
![Firewall Rule Created](./Screenshots_Lab1/04_Firewall_Rule_Created.png)

SSH connection established:  
![SSH Connected](./Screenshots_Lab1/05_SSH_Connected.png)

Application files extracted to the VM:  
![App Extracted](./Screenshots_Lab1/06_App_Extracted.png)

Flask application running on port 8080:  
![App Running](./Screenshots_Lab1/07_App_Running.png)

---

### ğŸ’¥ Task 3 â€“ Test for XSS Vulnerability

I accessed the web application using the static IP and port `8080` and tested for an XSS vulnerability by injecting the following payload:

```html
<script>alert('This is an XSS Injection to demonstrate one of OWASP vulnerabilities')</script>
```

The appearance of a JavaScript `alert()` popup confirmed the vulnerability.

ğŸ“¸ **Evidence:**  

Web form accessed and ready for injection:  
![App Form Accessed](./Screenshots_Lab1/08_App_Form_Accessed.png)

XSS payload triggered successfully:  
![XSS Alert Popup](./Screenshots_Lab1/09_XSS_Alert_Popup.png)

---

### ğŸ” Task 4 â€“ Scan the Application Using Web Security Scanner

I enabled the **Web Security Scanner API**, created a scan configuration for the target, and ran the scan. Logs showed scan execution and detection of the XSS vulnerability.

ğŸ“¸ **Evidence:**  

Web Security Scanner API enabled:  
![WSS API Enabled](./Screenshots_Lab1/10_WSS_API_Enabled.png)

WSS dashboard showing the scan project:  
![WSS Main Dashboard](./Screenshots_Lab1/11_WSS_Main_Dashboard.png)

Scan configuration created for the target:  
![WSS Scan Configured](./Screenshots_Lab1/12_WSS_Scan_Configured.png)

Scan logs monitored via SSH terminal:  
![SSH Terminal Scanner Logs](./Screenshots_Lab1/13_SSH_Terminal_Scanner_Logs.png)

XSS vulnerability detected in the scan report:  
![WSS XSS Found](./Screenshots_Lab1/14_WSS_XSS_Found.png)

---

### ğŸ› ï¸ Task 5 â€“ Remediate the XSS Vulnerability

I edited the `app.py` file to sanitize user input and escape HTML characters before rendering the output:

```python
output_string = "".join([html_escape_table.get(c, c) for c in input_string])
# output_string = input_string
```

After saving the changes, I restarted the Flask app to apply the fix.

ğŸ“¸ **Evidence:**  

Sanitization fix implemented in the code:  
![Code Fix XSS Escaping](./Screenshots_Lab1/15_Code_Fix_XSS_Escaping.png)

Application restarted with fixed code:  
![ReRun Fixed App](./Screenshots_Lab1/16_ReRun_Fixed_App.png)

---

### ğŸ” Task 6 â€“ Re-scan the Application

I launched a new scan to verify that the vulnerability had been fixed. The scan started successfully, but the lab expired before capturing the final â€œno vulnerabilitiesâ€ screen.

ğŸ“¸ **Evidence:**  

Re-scan launched after remediation:  
![ReScan Started](./Screenshots_Lab1/18_ReScan_Started.png)

> âŒ Skipped Screenshots:
> - `17_XSS_Sanitized_Proof.png`
> - `19_Scan_Complete_NoVulnerabilities.png`

---

## âœ… Summary & Key Takeaways

- **Cross-Site Scripting (XSS)** allows attackers to inject malicious scripts into websites and manipulate client-side behavior.
- **Web Security Scanner** is an effective tool to identify and confirm vulnerabilities in cloud-hosted applications.
- Implementing **input sanitization and HTML escaping** is a simple but powerful way to block XSS attacks.
- Security should be an ongoing process: scan, fix, and re-scan before deployment.

---

## ğŸš€ Uploading to GitHub

```bash
cd cloudsec-portfolio-starter
git add Labs/course-1302/Module-2-Vulnerability/Lab1-WebApp-Vulnerability
git commit -m "Add Lab 1 - XSS Vulnerability Scanning and Remediation"
git push origin main
```

---

## ğŸ“š References

- [OWASP â€“ Cross-Site Scripting (XSS)](https://owasp.org/www-community/attacks/xss/)
- [Google Cloud â€“ Web Security Scanner](https://cloud.google.com/security-scanner)
