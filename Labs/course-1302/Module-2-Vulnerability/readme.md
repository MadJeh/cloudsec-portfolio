# 🧪 Lab 1 – Web Application Vulnerabilities and Remediation Techniques

## 📝 Overview

In this lab, I worked as a **Security Analyst** to find and fix a **Cross-Site Scripting (XSS)** vulnerability in a web application. I deployed a vulnerable Python Flask app on a Google Cloud VM, tested it with an injection, scanned it using **Web Security Scanner (WSS)**, fixed the vulnerability in the code, and re-scanned to confirm the remediation.

---

## 🎯 Objectives

- Deploy a vulnerable Flask web app on Google Cloud.
- Simulate a Cross-Site Scripting (XSS) attack to confirm the vulnerability.
- Use **Web Security Scanner** to scan the application.
- Remediate the vulnerability with proper input sanitization.
- Re-run the scan to validate the fix.

---

## 🧰 Tools & Services Used

- **Google Cloud Platform (GCP)**
- **Compute Engine** (Virtual Machines)
- **Cloud Shell & SSH-in-browser**
- **Web Security Scanner (WSS)**
- **Python Flask Framework**

---

## 🔎 Task Breakdown

---

### 🧩 Task 1 – Launch a Virtual Machine

I created a VM on Google Cloud with no service account or additional scopes, then reserved a **static IP**. I also installed `python3-flask` using a startup script.

📸 **Evidence:**  

VM successfully created:  
![VM Created](./Screenshots_Lab1/01_VM_Created.png)

Static IP generated for external access:  
![Static IP Generated](./Screenshots_Lab1/02_Static_IP_Generated.png)

VM instance confirmation from Compute Engine:  
![VM Instance Confirmation](./Screenshots_Lab1/03_VM_Instance_Confirmation.png)

---

### 🔐 Task 2 – Set Up and Run the Vulnerable Application

I created a **firewall rule** to allow traffic on port `8080`, connected to the VM via SSH, downloaded the vulnerable Flask app, and started the server.

📸 **Evidence:**  

Firewall rule created to allow HTTP traffic:  
![Firewall Rule Created](./Screenshots_Lab1/04_Firewall_Rule_Created.png)

SSH connection established:  
![SSH Connected](./Screenshots_Lab1/05_SSH_Connected.png)

Application files extracted to the VM:  
![App Extracted](./Screenshots_Lab1/06_App_Extracted.png)

Flask application running on port 8080:  
![App Running](./Screenshots_Lab1/07_App_Running.png)

---

### 💥 Task 3 – Test for XSS Vulnerability

I accessed the web application using the static IP and port `8080` and tested for an XSS vulnerability by injecting the following payload:

```html
<script>alert('This is an XSS Injection to demonstrate one of OWASP vulnerabilities')</script>
```

The appearance of a JavaScript `alert()` popup confirmed the vulnerability.

📸 **Evidence:**  

Web form accessed and ready for injection:  
![App Form Accessed](./Screenshots_Lab1/08_App_Form_Accessed.png)

XSS payload triggered successfully:  
![XSS Alert Popup](./Screenshots_Lab1/09_XSS_Alert_Popup.png)

---

### 🔍 Task 4 – Scan the Application Using Web Security Scanner

I enabled the **Web Security Scanner API**, created a scan configuration for the target, and ran the scan. Logs showed scan execution and detection of the XSS vulnerability.

📸 **Evidence:**  

Web Security Scanner API enabled:  
![WSS API Enabled](./Screenshots_Lab1/10_WSS_API_Enabled.png)

WSS dashboard showing the scan project:  
![WSS Main Dashboard](./Screenshots_Lab1/11_WSS_Main_Dashboard.png)

Scan configuration created for the target:  
![WSS Scan Configured](./Screenshots_Lab1/12_WSS_Scan_Configured.png)

Scan logs monitored via SSH terminal:  
![SSH Terminal Scanner Logs](./Screenshots_Lab1/13_SSH_Terminal_Scanner_Logs.png)

XSS vulnerability detected in the scan report:  
![WSS XSS Found](./Screenshots_Lab1/14_WSS_XSS_Found.png)

---

### 🛠️ Task 5 – Remediate the XSS Vulnerability

I edited the `app.py` file to sanitize user input and escape HTML characters before rendering the output:

```python
output_string = "".join([html_escape_table.get(c, c) for c in input_string])
# output_string = input_string
```

After saving the changes, I restarted the Flask app to apply the fix.

📸 **Evidence:**  

Sanitization fix implemented in the code:  
![Code Fix XSS Escaping](./Screenshots_Lab1/15_Code_Fix_XSS_Escaping.png)

Application restarted with fixed code:  
![ReRun Fixed App](./Screenshots_Lab1/16_ReRun_Fixed_App.png)

---

### 🔁 Task 6 – Re-scan the Application

I launched a new scan to verify that the vulnerability had been fixed. The scan started successfully, but the lab expired before capturing the final “no vulnerabilities” screen.

📸 **Evidence:**  

Re-scan launched after remediation:  
![ReScan Started](./Screenshots_Lab1/18_ReScan_Started.png)

> ❌ Skipped Screenshots:
> - `17_XSS_Sanitized_Proof.png`
> - `19_Scan_Complete_NoVulnerabilities.png`

---

## ✅ Summary & Key Takeaways

- **Cross-Site Scripting (XSS)** allows attackers to inject malicious scripts into websites and manipulate client-side behavior.
- **Web Security Scanner** is an effective tool to identify and confirm vulnerabilities in cloud-hosted applications.
- Implementing **input sanitization and HTML escaping** is a simple but powerful way to block XSS attacks.
- Security should be an ongoing process: scan, fix, and re-scan before deployment.

---

## 🚀 Uploading to GitHub

```bash
cd cloudsec-portfolio-starter
git add Labs/course-1302/Module-2-Vulnerability/Lab1-WebApp-Vulnerability
git commit -m "Add Lab 1 - XSS Vulnerability Scanning and Remediation"
git push origin main
```

---

## 📚 References

- [OWASP – Cross-Site Scripting (XSS)](https://owasp.org/www-community/attacks/xss/)
- [Google Cloud – Web Security Scanner](https://cloud.google.com/security-scanner)
